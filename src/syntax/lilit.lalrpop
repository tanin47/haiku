use std::str::FromStr;
use syntax::tree::*;

grammar;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Exprs = Comma<Expr>;
pub Vars = Comma<Var>;
pub Params = Comma<Param>;

pub Mod: Box<Mod> = {
  <u:ModUnit*> => Box::new(Mod { units:u }),
};

ModUnit: Box<ModUnit> = {
	<Class> => Box::new(ModUnit::Class(<>)),
	<Func> => Box::new(ModUnit::Func(<>)),
};

Class: Box<Class> = {
  "class" <name:ClassName> "(" <params:Params> ")" <e:ClassExtend?> <methods:Func*> "end" => {
    let is_llvm = name.chars().next() == Some('@');
    Box::new(Class {
      name,
      params,
      extends: match e {
        None => vec![],
        Some(e) => e,
      },
      methods,
      is_llvm,
    })
  },
};

Param: Box<Param> = {
  <var:Var> ":" <tpe:ClassName> => Box::new(Param { var, tpe })
};

ClassExtend: Vec<String> = {
  "extends" <e:ClassName> <v:("," <ClassName>)*> => {
  	let mut v = v;
  	v.insert(0, e);
  	v
  }
};

ClassName: String = {
  r"@?[A-Z][a-zA-Z0-9_]*" => String::from(<>),
};

Func: Box<Func> = {
  "def" <name:Name> "(" <params:Params> ")" ":" <return_type: ClassName> <exprs:Expr*> "end" => Box::new(Func { name, params, return_type, exprs }),
};

Expr: Box<Expr> = {
  <Assignment>,
  <HighPrecedentExpr>
};

HighPrecedentExpr: Box<Expr> = {
  <DotInvoke>,
  <DotMember>,
  <Num> => Box::new(Expr::Num(<>)),
  <Boolean>,
  <Invoke> => Box::new(Expr::Invoke(<>)),
  <ReadVar>,
  <LiteralString>,
  <IfElse>,
  <ComparisonExpr>,
  <ClassInstance>,
  <LlvmInvoke>,
};

DotMember: Box<Expr> = {
  <expr:HighPrecedentExpr> "." <member:Var> => Box::new(Expr::DotMember(Box::new(DotMember { expr, member }))),
};

DotInvoke: Box<Expr> = {
  <expr:HighPrecedentExpr> "." <invoke:Invoke> => Box::new(Expr::DotInvoke(Box::new(DotInvoke { expr, invoke }))),
};

ClassInstance: Box<Expr> = {
  <name:ClassName> "(" <params:Exprs> ")" => Box::new(Expr::ClassInstance(Box::new(ClassInstance { name, params }))),
};

// TODO(tanin): Comparison should take Exprs. But there is a problem with ambiguity. We should handle it
ComparisonExpr: Box<Expr> = {
  <Comparison> => Box::new(Expr::Comparison(<>)),
};

Comparison: Box<Comparison> = {
  <left:Var> ">" <right:Num> => Box::new(Comparison { left, right }),
};

IfElse: Box<Expr> = {
  "if" <cond: Comparison> "{" <true_br: Expr> "}" "else" "{" <false_br: Expr> "}" => Box::new(Expr::IfElse(Box::new(IfElse { cond, true_br, false_br }))),
};

LiteralString: Box<Expr> = {
  r#""[^"]*""# => {
    let s = String::from(<>);
    let len = s.len();
    Box::new(Expr::LiteralString(Box::new(LiteralString { content: String::from(&s[1..len-1]) })))
  }
};

Assignment: Box<Expr> = {
  "val" <var:Var> "="  <expr:Expr> => Box::new(Expr::Assignment(Box::new(Assignment { var, expr })))
};

Invoke: Box<Invoke> = {
  <name:Name> "(" <args:Exprs> ")" => Box::new(Invoke { name, args  }),
};

LlvmInvoke: Box<Expr> = {
  <name_with_return_type:LlvmInvokeName> "(" <args:Exprs> ")" => {
    let mut tokens = name_with_return_type.split(':');
    let return_type = String::from(tokens.next().unwrap());
    let name = String::from(tokens.next().unwrap());
    let is_varargs = name.chars().last() == Some('+');
    let name = if name.chars().last() == Some('+') {
      let len = name.len();
      String::from(&name[0..len-1])
    } else {
      name
    };
    Box::new(Expr::LlvmInvoke(Box::new(LlvmInvoke { name, is_varargs, return_type, args  })))
  }
}

ReadVar: Box<Expr> = {
  <Var> => Box::new(Expr::Var(<>))
};

Var: Box<Var> = {
  <Name> => Box::new(Var { name: <> })
};

LlvmInvokeName: String = {
  r"@[A-Z][A-Za-z0-9_]*:[a-z][A-Za-z0-9_]*\+?" => String::from(<>),
};

Name: String = {
  r"[a-z][A-Za-z0-9_]*" => String::from(<>),
};

Boolean: Box<Expr> = {
  "true" => Box::new(Expr::Boolean(Box::new(Boolean { value: true }))),
  "false" => Box::new(Expr::Boolean(Box::new(Boolean { value: false }))),
};

Num: Box<Num> = {
  r"[0-9]+" => Box::new(Num { value: i32::from_str(<>).unwrap() }),
};
