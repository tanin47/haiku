use std::str::FromStr;
use std::rc::Rc;
use ast::*;

grammar;

pub Mod: Rc<Mod> = {
  <u:ModUnit*> => Rc::new(Mod { units:u }),
};

ModUnit: Rc<ModUnit> = {
	<Class> => Rc::new(ModUnit::Class(<>)),
	<Func> => Rc::new(ModUnit::Func(<>)),
};

Class: Rc<Class> = {
  "class" <n:Name> <e:ClassExtend?> <m:Func*> "end" => Rc::new(Class {
    name:n,
    extends: match e {
    	None => vec![],
    	Some(e) => e,
    },
    methods:m,
  })
};

ClassExtend: Vec<String> = {
  "extends" <e:Name> <v:("," <Name>)*> => {
  	let mut v = v;
  	v.insert(0, e);
  	v
  }
};

Func: Rc<Func> = {
  "def" <id:Id> "(" ")" <exprs:Expr*> "end" => Rc::new(Func { id:id, exprs:exprs }),
};

Expr: Rc<Expr> = {
  <Num>,
  <Invoke>,
  <Assignment>,
  <ReadVar>,
};

Assignment: Rc<Expr> = {
  "val" <var:Var> "="  <expr:Expr> => Rc::new(Expr::Assignment(Rc::new(Assignment { var, expr })))
}

Invoke: Rc<Expr> = {
  <Id> "(" ")" => Rc::new(Expr::Invoke(Rc::new(Invoke { id: <> }))),
};

ReadVar: Rc<Expr> = {
  <Var> => Rc::new(Expr::Var(<>))
}

Var: Rc<Var> = {
  <Id> => Rc::new(Var { id: <> })
}

Id: Rc<Id> = {
  r"[a-z][a-z0-9_]*" => Rc::new(Id { name: String::from(<>) }),
};

Name: String = {
  r"[A-Z][a-zA-Z0-9_]*" => String::from(<>),
};

Num: Rc<Expr> = {
  r"[0-9]+" => Rc::new(Expr::Num(Rc::new(Num { value: i32::from_str(<>).unwrap() }))),
};
